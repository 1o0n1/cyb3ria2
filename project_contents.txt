/var/www/cyb3ria/.env

# ВАЖНО: Никогда не добавляйте этот файл в git!
# Формат: postgres://ПОЛЬЗОВАТЕЛЬ:ПАРОЛЬ@ХОСТ:ПОРТ/ИМЯ_БАЗЫ_ДАННЫХ
DATABASE_URL="postgres://cyb3ria:!Abs123@localhost:5432/cyb3ria"
JWT_SECRET="a-very-long-and-super-secret-string-for-jwt"



/var/www/cyb3ria/Cargo.toml

[package]
name = "cyb3ria"
version = "0.1.0"
edition = "2024"

[dependencies]
# Основные библиотеки
axum = { version = "0.8.4", features = ["macros"] }
warp = "0.3.7"       # Веб-фреймворк
tokio = { version = "1.47.0", features = ["full"] } # Tokio - асинхронный рантайм. Нужна фича "full" для всех его возможностей.
futures = "0.3.30"
serde = { version = "1.0.203", features = ["derive"] } # Serde - для (де)сериализации, особенно в JSON.
serde_json = "1.0.117"
log = "0.4"        # Логирование
env_logger = "0.9"  # Вывод логов в консоль
dotenvy = "0.15.7" # Dotenvy - для чтения .env файлов.
sqlx = { version = "0.8.0", features = ["runtime-tokio-rustls", "postgres", "uuid", "chrono"] } # SQLx - для работы с PostgreSQL. Включаем нужный рантайм и драйвер.
tracing = "0.1.41" # Tracing - для логирования. Нужна фича "env-filter" для фильтрации логов.
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
tower-http = { version = "0.5.2", features = ["trace"] }
argon2 = "0.5"
uuid = { version = "1.9.1", features = ["serde", "v4"] }
jsonwebtoken = "9"
validator = { version = "0.16", features = ["derive"] }
time = "0.3"
chrono = { version = "0.4.38", features = ["serde"] }
rand = "0.8"




/var/www/cyb3ria/src/main.rs

use std::net::SocketAddr;
use dotenvy::dotenv;
use std::env;
use tokio::net::TcpListener;
use tower_http::trace::TraceLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};


mod db;
mod routes;
mod models;
mod handlers;
mod error;
mod state;
mod config;
mod auth;

use state::AppState;
use config::Config;

#[tokio::main]
async fn main() {
    dotenv().ok();

    // Настройка логирования
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "cyb3ria=debug,tower_http=debug".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    let config = Config::from_env();

    // Подключение к БД
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let pool = db::connect_db(&database_url).await;
    
    // Создание состояния приложения
    let app_state = AppState { 
        pool,
        config,
     };

    // Создание роутера с состоянием
    let app = routes::create_routes(app_state)
        .layer(TraceLayer::new_for_http());

    // Запуск сервера
    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));
    tracing::debug!("Listening on {}", addr);
    let listener = TcpListener::bind(&addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}



/var/www/cyb3ria/src/db.rs

use sqlx::postgres::PgPoolOptions;
use sqlx::PgPool;

pub async fn connect_db(database_url: &str) -> PgPool {
    PgPoolOptions::new()
        .max_connections(5)
        .connect(database_url)
        .await
        .expect("Не удалось подключиться к базе данных")
}




/var/www/cyb3ria/src/error.rs

use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;

// Наш кастомный тип ошибки.
#[derive(Debug)]
pub enum AppError {
    SqlxError(sqlx::Error),
    // НОВЫЙ ВАРИАНТ для ошибок хэширования
    PasswordHashError(argon2::password_hash::Error),
    NotFound,
    Unauthorized,
    InvalidCredentials, // <- ошибка для неудачного входа
    InternalServerError, // <- общая ошибка 500
     
}

// Реализация преобразования ошибки в HTTP-ответ.
impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, error_message) = match self {
            AppError::SqlxError(e) => {
                tracing::error!("SQLx error: {:?}", e);
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    "Internal Server Error".to_string(),
                )
            }
            // НОВЫЙ БЛОК для обработки ошибки хэширования
            AppError::PasswordHashError(e) => {
                tracing::error!("Password hashing error: {:?}", e);
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    "Internal Server Error".to_string(),
                )
            }
            AppError::InvalidCredentials => {
                (StatusCode::UNAUTHORIZED, "Invalid email or password".to_string())
            }
            AppError::InternalServerError => {
                (StatusCode::INTERNAL_SERVER_ERROR, "An internal error occurred".to_string())
            }
            AppError::Unauthorized => {
                (StatusCode::UNAUTHORIZED, "Authentication required".to_string())
            }
            AppError::NotFound => (StatusCode::NOT_FOUND, "Resource not found".to_string()),

        };

        let body = Json(json!({ "error": error_message }));
        (status, body).into_response()
    }
}

// Позволяет использовать `?` для `sqlx::Error`.
impl From<sqlx::Error> for AppError {
    fn from(err: sqlx::Error) -> Self {
        match err {
            sqlx::Error::RowNotFound => AppError::NotFound,
            _ => AppError::SqlxError(err),
        }
    }
}

// НОВАЯ РЕАЛИЗАЦИЯ: Позволяет использовать `?` для `argon2::password_hash::Error`.
impl From<argon2::password_hash::Error> for AppError {
    fn from(err: argon2::password_hash::Error) -> Self {
        AppError::PasswordHashError(err)
    }
}



/var/www/cyb3ria/src/state.rs

use sqlx::PgPool;
use crate::config::Config;

// Структура состояния, которую мы будем передавать во все хендлеры.
// `#[derive(Clone)]` необходим, т.к. Axum будет клонировать его для каждого потока.
#[derive(Clone)]
pub struct AppState {
    pub pool: PgPool,
    pub config: Config,
}



/var/www/cyb3ria/src/routes/mod.rs

use axum::{Router, middleware};
use crate::state::AppState;
use crate::auth::auth_middleware;

mod users;
mod messages;
mod discussions;
mod comments;

pub fn create_routes(app_state: AppState) -> Router {
    // Роуты, которые НЕ требуют аутентификации
    let public_routes = Router::new()
        .merge(users::create_public_user_routes());

    // Роуты, которые ТРЕБУЮТ аутентификации
    let protected_routes = Router::new()
        .merge(users::create_protected_user_routes())
        .merge(messages::create_message_routes())
        .merge(discussions::create_discussion_routes())
        .merge(comments::create_comment_routes())
        .layer(middleware::from_fn_with_state(app_state.clone(), auth_middleware));

    // Объединяем все в один роутер
    Router::new()
        .merge(public_routes)
        .merge(protected_routes)
        .with_state(app_state)
}



/var/www/cyb3ria/src/routes/users.rs

use axum::{Router, routing::{get, post}};
use crate::state::AppState;
use crate::handlers::user_handler;

// Роуты, не требующие аутентификации
pub fn create_public_user_routes() -> Router<AppState> {
    Router::new()
        .route("/users", post(user_handler::create_user))
        .route("/login", post(user_handler::login))
}

// Роуты, требующие аутентификации
pub fn create_protected_user_routes() -> Router<AppState> {
    Router::new()
        .route("/users/{id}", get(user_handler::get_user))
}



/var/www/cyb3ria/src/routes/messages.rs

use axum::{Router, routing::{get, post}};
use crate::state::AppState;
use crate::handlers::message_handler; // <- Указываем на новый хендлер

pub fn create_message_routes() -> Router<AppState> {
    Router::new()
        .route("/messages", post(message_handler::create_message))
        .route("/messages/{id}", get(message_handler::get_message))
}



/var/www/cyb3ria/src/routes/discussions.rs

use axum::{Router, routing::{get, post}};
use crate::state::AppState;
use crate::handlers::discussion_handler; // <- Указываем на новый хендлер

pub fn create_discussion_routes() -> Router<AppState> {
    Router::new()
        .route("/discussions", post(discussion_handler::create_discussion))
        .route("/discussions/{id}", get(discussion_handler::get_discussion))
}



/var/www/cyb3ria/src/routes/comments.rs

use axum::{Router, routing::{get, post}};
use crate::state::AppState;
use crate::handlers::comment_handler; // <- Указываем на новый хендлер

pub fn create_comment_routes() -> Router<AppState> {
    Router::new()
        .route("/comments", post(comment_handler::create_comment))
        .route("/comments/{id}", get(comment_handler::get_comment))
}



/var/www/cyb3ria/src/handlers/mod.rs

pub mod user_handler;
pub mod message_handler;
pub mod discussion_handler;
pub mod comment_handler;



/var/www/cyb3ria/src/handlers/user_handler.rs

// /var/www/cyb3ria/src/handlers/user_handler.rs

// --- БЛОК 1: Импорты ---
use axum::{
    extract::{Path, State},
    Json,
};
use uuid::Uuid;
use argon2::{
    password_hash::{
        rand_core::OsRng,
        PasswordVerifier,
        PasswordHasher, 
        SaltString
    },
    Argon2
};
// Новые импорты для JWT
use jsonwebtoken::{encode, EncodingKey, Header};
use chrono::{Utc, Duration};
use serde::{Serialize, Deserialize}; // Добавили Deserialize для Claims
use crate::auth::Claims; 

use crate::{
    state::AppState,
    models::user::User,
    error::AppError,
};


// --- БЛОК 2: Структура для создания пользователя ---
#[derive(Deserialize)]
pub struct CreateUserPayload {
    pub username: String,
    pub email: String,
    pub password: String,
}

// --- БЛОК 3: Функция создания пользователя (остается без изменений) ---
pub async fn create_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUserPayload>,
) -> Result<Json<User>, AppError> {
    // ... ваш работающий код для create_user ...
    let password_hash = tokio::task::spawn_blocking(move || {
        let salt = SaltString::generate(&mut OsRng);
        Argon2::default()
            .hash_password(payload.password.as_bytes(), &salt)
            .map(|hash| hash.to_string())
    })
    .await
    .map_err(|e| {
        tracing::error!("JoinError during password hashing: {:?}", e);
        AppError::PasswordHashError(argon2::password_hash::Error::PhcStringField)
    })?
    ?;
    
    let user = sqlx::query_as!(
        User,
        "INSERT INTO users (username, email, password_hash) VALUES ($1, $2, $3) RETURNING *",
        payload.username,
        payload.email,
        password_hash
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(user))
}

// --- БЛОК 4: Функция получения пользователя (остается без изменений) ---
pub async fn get_user(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<Json<User>, AppError> {
    let user = sqlx::query_as!(
        User,
        "SELECT * FROM users WHERE id = $1",
        id
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(user))
}

// --- БЛОК 5: Структура для данных входа (остается без изменений) ---
#[derive(Deserialize)]
pub struct LoginPayload {
    pub email: String,
    pub password: String,
}

// Структура для ответа API после успешного входа
#[derive(Serialize)]
pub struct AuthResponse {
    token: String,
}

// --- БЛОК 7: ОБНОВЛЕННАЯ функция login ---
pub async fn login(
    State(state): State<AppState>,
    Json(payload): Json<LoginPayload>,
) -> Result<Json<AuthResponse>, AppError> { // Обратите внимание на тип возврата!
    // 1. Найти пользователя по email
    let user = sqlx::query_as!(
        User,
        "SELECT * FROM users WHERE email = $1",
        payload.email
    )
    .fetch_optional(&state.pool)
    .await?
    .ok_or(AppError::InvalidCredentials)?;

    // 2. Проверить и склонировать хэш пароля
    let password_hash = user.password_hash.clone().ok_or(AppError::InvalidCredentials)?;

    // 3. Сравнить пароль с хэшем
    let password = payload.password;
    let verification_result = tokio::task::spawn_blocking(move || {
        let parsed_hash = match argon2::PasswordHash::new(&password_hash) {
            Ok(hash) => hash,
            Err(e) => return Err(e),
        };
        Argon2::default().verify_password(password.as_bytes(), &parsed_hash)
    })
    .await
    .map_err(|e| {
        tracing::error!("JoinError during password verification: {:?}", e);
        AppError::InternalServerError
    })?;

    // Если пароль верный, генерируем токен
    if verification_result.is_ok() {
        // --- Начало блока генерации JWT ---
        let now = Utc::now();
        // let iat = now.timestamp(); // iat (issued at) обычно не нужен, т.к. есть exp
        let exp = (now + Duration::days(1)).timestamp(); // Токен живет 1 дней
        
        let claims = Claims {
            sub: user.id,
            exp,
        };

        let token = encode(
            &Header::default(),
            &claims,
            &EncodingKey::from_secret(state.config.jwt_secret.as_ref()),
        )
        .map_err(|e| {
            tracing::error!("JWT encoding error: {:?}", e);
            AppError::InternalServerError
        })?;
        // --- Конец блока генерации JWT ---

        // Возвращаем токен
        Ok(Json(AuthResponse { token }))
    } else {
        // Если пароль неверный
        tracing::debug!("Invalid password attempt for email: {}", payload.email);
        Err(AppError::InvalidCredentials)
    }
}



/var/www/cyb3ria/src/handlers/message_handler.rs

// /var/www/cyb3ria/src/handlers/message_handler.rs

use axum::{
    extract::{Path, State, Json},
    Extension, // <-- Новый экстрактор!
};
// ... другие импорты
use uuid::Uuid;
use crate::{
    state::AppState,
    models::message::Message,
    error::AppError,
};
// ...

#[derive(serde::Deserialize)]
pub struct CreateMessagePayload {
    pub content: String,
}

#[axum::debug_handler]
pub async fn create_message(
    Extension(user_id): Extension<Uuid>, // <-- ВОТ ТАК мы получаем ID!
    State(state): State<AppState>,
    Json(payload): Json<CreateMessagePayload>,
) -> Result<Json<Message>, AppError> {
    let message = sqlx::query_as!(
        Message,
        "INSERT INTO messages (user_id, content) VALUES ($1, $2) RETURNING *",
        user_id, // <-- Используем ID из расширений
        payload.content
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(message))
}

// ... get_message остается без изменений ...
pub async fn get_message(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<Json<Message>, AppError> {
    let message = sqlx::query_as!(
        Message,
        "SELECT * FROM messages WHERE id = $1",
        id
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(message))
}



/var/www/cyb3ria/src/handlers/discussion_handler.rs

use axum::{
    extract::{Path, State},
    Json,
};
use uuid::Uuid;
use crate::{
    state::AppState,
    models::discussion::Discussion,
    error::AppError,
};

#[derive(serde::Deserialize)]
pub struct CreateDiscussionPayload {
    pub title: String,
    pub author_id: Uuid,
}

pub async fn create_discussion(
    State(state): State<AppState>,
    Json(payload): Json<CreateDiscussionPayload>,
) -> Result<Json<Discussion>, AppError> {
    let discussion = sqlx::query_as!(
        Discussion,
        "INSERT INTO discussions (title, author_id) VALUES ($1, $2) RETURNING *",
        payload.title,
        payload.author_id
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(discussion))
}

pub async fn get_discussion(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<Json<Discussion>, AppError> {
    let discussion = sqlx::query_as!(
        Discussion,
        "SELECT * FROM discussions WHERE id = $1",
        id
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(discussion))
}



/var/www/cyb3ria/src/handlers/comment_handler.rs

use axum::{
    extract::{Path, State},
    Json,
};
use uuid::Uuid;
use crate::{
    state::AppState,
    models::comment::Comment,
    error::AppError,
};

#[derive(serde::Deserialize)]
pub struct CreateCommentPayload {
    pub discussion_id: Uuid,
    pub author_id: Uuid,
    pub content: String,
}

pub async fn create_comment(
    State(state): State<AppState>,
    Json(payload): Json<CreateCommentPayload>,
) -> Result<Json<Comment>, AppError> {
    let comment = sqlx::query_as!(
        Comment,
        "INSERT INTO comments (discussion_id, author_id, content) VALUES ($1, $2, $3) RETURNING *",
        payload.discussion_id,
        payload.author_id,
        payload.content
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(comment))
}

pub async fn get_comment(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<Json<Comment>, AppError> {
    let comment = sqlx::query_as!(
        Comment,
        "SELECT * FROM comments WHERE id = $1",
        id
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(comment))
}



/var/www/cyb3ria/src/models/mod.rs

pub mod user;
pub mod message;
pub mod discussion;
pub mod comment;




/var/www/cyb3ria/src/models/user.rs

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct User {
    pub id: Uuid,
    pub username: String,
    pub email: String,

    // Добавляем недостающее поле
    // Оно Option<String>, так как в БД колонка может быть NULL.
    // Оно скрыто из JSON-ответов для безопасности.
    #[serde(skip_serializing)]
    pub password_hash: Option<String>,

    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}



/var/www/cyb3ria/src/models/message.rs

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

// Убедитесь, что здесь НЕТ поля `discussion_id`.
#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct Message {
    pub id: Uuid,
    pub user_id: Uuid,
    pub content: String,
    pub created_at: DateTime<Utc>,
}



/var/www/cyb3ria/src/models/discussion.rs

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct Discussion {
    pub id: Uuid,
    pub title: String,
    pub author_id: Uuid, // <- Добавлено это поле
    pub created_at: DateTime<Utc>,
}



/var/www/cyb3ria/src/models/comment.rs

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct Comment {
    pub id: Uuid,
    pub discussion_id: Uuid,
    pub author_id: Uuid, // <- Переименовано с user_id на author_id
    pub content: String,
    pub created_at: DateTime<Utc>,
}








