/var/www/cyb3ria/.env

# ВАЖНО: Никогда не добавляйте этот файл в git!
# Формат: postgres://ПОЛЬЗОВАТЕЛЬ:ПАРОЛЬ@ХОСТ:ПОРТ/ИМЯ_БАЗЫ_ДАННЫХ
DATABASE_URL="postgres://cyb3ria:!Abs123@localhost:5432/cyb3ria"
JWT_SECRET="a-very-long-and-super-secret-string-for-jwt"



/var/www/cyb3ria/Cargo.toml

[package]
name = "cyb3ria"
version = "0.1.0"
edition = "2024"

[dependencies]
# Основные библиотеки
axum = { version = "0.8.4", features = ["macros"] }
tokio = { version = "1.47.0", features = ["full"] } # Tokio - асинхронный рантайм. Нужна фича "full" для всех его возможностей.
futures = "0.3.30"
serde = { version = "1.0.203", features = ["derive"] } # Serde - для (де)сериализации, особенно в JSON.
serde_json = "1.0.117"
log = "0.4"        # Логирование
env_logger = "0.9"  # Вывод логов в консоль
dotenvy = "0.15.7" # Dotenvy - для чтения .env файлов.
sqlx = { version = "0.8.0", features = ["runtime-tokio-rustls", "postgres", "uuid", "chrono"] } # SQLx - для работы с PostgreSQL. Включаем нужный рантайм и драйвер.
tracing = "0.1.41" # Tracing - для логирования. Нужна фича "env-filter" для фильтрации логов.
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
tower-http = { version = "0.5.2", features = ["trace", "cors"] }
argon2 = "0.5"
uuid = { version = "1.9.1", features = ["serde", "v4"] }
jsonwebtoken = "9"
validator = { version = "0.16", features = ["derive"] }
time = "0.3"
chrono = { version = "0.4.38", features = ["serde"] }
rand = "0.8"




/var/www/cyb3ria/src/main.rs

use std::net::SocketAddr;
use dotenvy::dotenv;
use std::env;
use tokio::net::TcpListener;
use axum::http::Method; // <-- Перенес импорт Method наверх для порядка

// --- ЕДИНСТВЕННЫЙ И ПРАВИЛЬНЫЙ БЛОК ИМПОРТОВ TOWER_HTTP ---
use tower_http::{
    cors::CorsLayer,
    trace::TraceLayer,
};
// --- КОНЕЦ БЛОКА ---

use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

// --- Подключаем все наши модули (без изменений) ---
mod db;
mod routes;
mod models;
mod handlers;
mod error;
mod state;
mod config;
mod auth;

use state::AppState;
use config::Config;

#[tokio::main]
async fn main() {
    dotenv().ok();

    // Настройка логирования (без изменений)
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "cyb3ria=debug,tower_http=debug".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    let config = Config::from_env();

    // Подключение к БД (без изменений)
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let pool = db::connect_db(&database_url).await;
    
    // Создание состояния приложения (без изменений)
    let app_state = AppState { 
        pool,
        config,
     };

    // --- ОБНОВЛЕННЫЙ БЛОК: НАСТРОЙКА CORS ---
    let cors = CorsLayer::new()
        // ИЗМЕНЕНИЕ ЗДЕСЬ: Мы создаем список разрешенных источников
        .allow_origin([
            "http://localhost:8000".parse::<axum::http::HeaderValue>().unwrap(),
            "http://192.168.1.45:8000".parse::<axum::http::HeaderValue>().unwrap(),
            // Можешь добавить и IP другого устройства, с которого заходил, на всякий случай
            "http://192.168.1.96:8000".parse::<axum::http::HeaderValue>().unwrap(), 
        ])
        .allow_headers([
            axum::http::header::AUTHORIZATION,
            axum::http::header::CONTENT_TYPE
        ])
        .allow_methods([Method::GET, Method::POST, Method::PATCH, Method::DELETE]);
    // --- КОНЕЦ ОБНОВЛЕННОГО БЛОКА ---

    // Создание роутера с состоянием и слоями
    let app = routes::create_routes(app_state)
        .layer(TraceLayer::new_for_http())
        .layer(cors);

    // Запуск сервера (без изменений)
    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));
    tracing::debug!("Listening on {}", addr);
    let listener = TcpListener::bind(&addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}



/var/www/cyb3ria/src/db.rs

use sqlx::postgres::PgPoolOptions;
use sqlx::PgPool;

pub async fn connect_db(database_url: &str) -> PgPool {
    PgPoolOptions::new()
        .max_connections(5)
        .connect(database_url)
        .await
        .expect("Не удалось подключиться к базе данных")
}




/var/www/cyb3ria/src/error.rs

use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;

// Наш кастомный тип ошибки.
#[derive(Debug)]
pub enum AppError {
    SqlxError(sqlx::Error),
    // НОВЫЙ ВАРИАНТ для ошибок хэширования
    PasswordHashError(argon2::password_hash::Error),
    NotFound,
    Unauthorized,
    InvalidCredentials, // <- ошибка для неудачного входа
    InternalServerError, // <- общая ошибка 500
     
}

// Реализация преобразования ошибки в HTTP-ответ.
impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, error_message) = match self {
            AppError::SqlxError(e) => {
                tracing::error!("SQLx error: {:?}", e);
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    "Internal Server Error".to_string(),
                )
            }
            // НОВЫЙ БЛОК для обработки ошибки хэширования
            AppError::PasswordHashError(e) => {
                tracing::error!("Password hashing error: {:?}", e);
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    "Internal Server Error".to_string(),
                )
            }
            AppError::InvalidCredentials => {
                (StatusCode::UNAUTHORIZED, "Invalid email or password".to_string())
            }
            AppError::InternalServerError => {
                (StatusCode::INTERNAL_SERVER_ERROR, "An internal error occurred".to_string())
            }
            AppError::Unauthorized => {
                (StatusCode::UNAUTHORIZED, "Authentication required".to_string())
            }
            AppError::NotFound => (StatusCode::NOT_FOUND, "Resource not found".to_string()),

        };

        let body = Json(json!({ "error": error_message }));
        (status, body).into_response()
    }
}

// Позволяет использовать `?` для `sqlx::Error`.
impl From<sqlx::Error> for AppError {
    fn from(err: sqlx::Error) -> Self {
        match err {
            sqlx::Error::RowNotFound => AppError::NotFound,
            _ => AppError::SqlxError(err),
        }
    }
}

// НОВАЯ РЕАЛИЗАЦИЯ: Позволяет использовать `?` для `argon2::password_hash::Error`.
impl From<argon2::password_hash::Error> for AppError {
    fn from(err: argon2::password_hash::Error) -> Self {
        AppError::PasswordHashError(err)
    }
}



/var/www/cyb3ria/src/state.rs

use sqlx::PgPool;
use crate::config::Config;

// Структура состояния, которую мы будем передавать во все хендлеры.
// `#[derive(Clone)]` необходим, т.к. Axum будет клонировать его для каждого потока.
#[derive(Clone)]
pub struct AppState {
    pub pool: PgPool,
    pub config: Config,
}



/var/www/cyb3ria/src/config.rs

// /var/www/cyb3ria/src/config.rs
use std::env;

#[derive(Clone)]
pub struct Config {
    pub jwt_secret: String,
}

impl Config {
    pub fn from_env() -> Self {
        Self {
            jwt_secret: env::var("JWT_SECRET").expect("JWT_SECRET must be set"),
        }
    }
}



/var/www/cyb3ria/src/auth.rs

// /var/www/cyb3ria/src/auth.rs

use axum::{
    body::Body,
    http::{Request},
    middleware::Next,
    response::Response,
    extract::State,
};
use jsonwebtoken::{decode, DecodingKey, Validation};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use crate::{state::AppState, error::AppError};

// Claims остаются публичными, так как используются и в user_handler
#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: Uuid,
    pub exp: i64,
    pub pk: String, // <-- НОВОЕ ПОЛЕ: Public Key в base64
}

pub async fn auth_middleware(
    State(state): State<AppState>,
    mut request: Request<Body>,
    next: Next,
) -> Result<Response, AppError> {
    let token = request.headers()
        .get("Authorization")
        .and_then(|auth_header| auth_header.to_str().ok())
        .and_then(|auth_value| auth_value.strip_prefix("Bearer "))
        .ok_or(AppError::Unauthorized)?;

    let claims = decode::<Claims>(
        token,
        &DecodingKey::from_secret(state.config.jwt_secret.as_ref()),
        &Validation::default(),
    )
    .map_err(|_| AppError::Unauthorized)?
    .claims;

    request.extensions_mut().insert(claims.sub);

    Ok(next.run(request).await)
}



/var/www/cyb3ria/src/routes/mod.rs

use axum::{Router, middleware};
use crate::state::AppState;
use crate::auth::auth_middleware;

mod users;
mod messages;
mod discussions;
mod comments;

pub fn create_routes(app_state: AppState) -> Router {
    // Роуты, которые НЕ требуют аутентификации
    let public_routes = Router::new()
        .merge(users::create_public_user_routes());

    // Роуты, которые ТРЕБУЮТ аутентификации
    let protected_routes = Router::new()
        .merge(users::create_protected_user_routes())
        .merge(messages::create_message_routes())
        .merge(discussions::create_discussion_routes())
        .merge(comments::create_comment_routes())
        .layer(middleware::from_fn_with_state(app_state.clone(), auth_middleware));

    // Объединяем все в один роутер
    Router::new()
        .merge(public_routes)
        .merge(protected_routes)
        .with_state(app_state)
}



/var/www/cyb3ria/src/routes/users.rs

// /var/www/cyb3ria/src/routes/users.rs

use axum::{Router, routing::{get, post}};
use crate::state::AppState;
use crate::handlers::user_handler;

// --- ВОТ ЭТА ФУНКЦИЯ ПРОПАЛА ---
// Роуты, не требующие аутентификации (регистрация и вход)
pub fn create_public_user_routes() -> Router<AppState> {
    Router::new()
        .route("/users", post(user_handler::create_user))
        .route("/login", post(user_handler::login))
}
// --- КОНЕЦ ВОССТАНОВЛЕННОГО БЛОКА ---

// Роуты, требующие аутентификации (получение инфо о юзере и списка всех юзеров)
pub fn create_protected_user_routes() -> Router<AppState> {
    Router::new()
        .route("/users", get(user_handler::get_all_users)) // <- Получение списка
        .route("/users/{id}", get(user_handler::get_user))   // <- Получение одного по ID
}



/var/www/cyb3ria/src/routes/messages.rs

use axum::{Router, routing::{get, post}};
use crate::state::AppState;
use crate::handlers::message_handler; // <- Указываем на новый хендлер

pub fn create_message_routes() -> Router<AppState> {
    Router::new()
        .route("/messages", post(message_handler::create_message))
        .route("/messages/{partner_id}", get(message_handler::get_conversation_with))
}



/var/www/cyb3ria/src/routes/discussions.rs

use axum::{Router, routing::{get, post}};
use crate::state::AppState;
use crate::handlers::discussion_handler; // <- Указываем на новый хендлер

pub fn create_discussion_routes() -> Router<AppState> {
    Router::new()
        .route("/discussions", post(discussion_handler::create_discussion))
        .route("/discussions/{id}", get(discussion_handler::get_discussion))
}



/var/www/cyb3ria/src/routes/comments.rs

use axum::{Router, routing::{get, post}};
use crate::state::AppState;
use crate::handlers::comment_handler; // <- Указываем на новый хендлер

pub fn create_comment_routes() -> Router<AppState> {
    Router::new()
        .route("/comments", post(comment_handler::create_comment))
        .route("/comments/{id}", get(comment_handler::get_comment))
}



/var/www/cyb3ria/src/handlers/mod.rs

pub mod user_handler;
pub mod message_handler;
pub mod discussion_handler;
pub mod comment_handler;



/var/www/cyb3ria/src/handlers/user_handler.rs

// /var/www/cyb3ria/src/handlers/user_handler.rs

// --- БЛОК 1: Импорты ---
use axum::{
    extract::{Path, State},
    Json,
};
use uuid::Uuid;
use argon2::{
    password_hash::{
        rand_core::OsRng,
        PasswordVerifier,
        PasswordHasher, 
        SaltString
    },
    Argon2
};
// Новые импорты для JWT
use jsonwebtoken::{encode, EncodingKey, Header};
use chrono::{Utc, Duration};
use serde::{Serialize, Deserialize}; // Добавили Deserialize для Claims
use crate::auth::Claims; 

use crate::{
    state::AppState,
    models::user::User,
    error::AppError,
};

// --- НОВАЯ СТРУКТУРА для ответа ---
// Мы не хотим отдавать все поля User, особенно хэш пароля.
// Создадим специальную "безопасную" структуру для ответа.
#[derive(Serialize, sqlx::FromRow)]
pub struct SafeUser {
    pub id: Uuid,
    pub username: String,
    pub public_key: Option<String>,
}

// --- НОВАЯ ФУНКЦИЯ ---
pub async fn get_all_users(
    State(state): State<AppState>,
) -> Result<Json<Vec<SafeUser>>, AppError> {
    let users = sqlx::query_as::<_, SafeUser>(
        "SELECT id, username, public_key FROM users"
    )
    .fetch_all(&state.pool)
    .await?;

    Ok(Json(users))
}

// --- БЛОК 2: Структура для создания пользователя ---
#[derive(Deserialize)]
pub struct CreateUserPayload {
    pub username: String,
    pub email: String,
    pub password: String,
    pub public_key: String,
}

// --- БЛОК 3: Функция создания пользователя (остается без изменений) ---
pub async fn create_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUserPayload>,
) -> Result<Json<User>, AppError> {
    // ... ваш работающий код для create_user ...
    let password_hash = tokio::task::spawn_blocking(move || {
        let salt = SaltString::generate(&mut OsRng);
        Argon2::default()
            .hash_password(payload.password.as_bytes(), &salt)
            .map(|hash| hash.to_string())
    })
    .await
    .map_err(|e| {
        tracing::error!("JoinError during password hashing: {:?}", e);
        AppError::PasswordHashError(argon2::password_hash::Error::PhcStringField)
    })?
    ?;
    
    let new_user_id = sqlx::query!(
        "INSERT INTO users (username, email, password_hash, public_key) VALUES ($1, $2, $3, $4) RETURNING id",
         payload.username,
        payload.email,
        password_hash,
        payload.public_key
    )
    .fetch_one(&state.pool)
    .await?
    .id;

    // 2. Теперь, когда мы знаем ID, делаем чистый SELECT, чтобы получить полную структуру User.
    //    Так sqlx точно сможет правильно сопоставить типы.
    let user = sqlx::query_as!(
        User,
        "SELECT * FROM users WHERE id = $1",
        new_user_id
    )
    .fetch_one(&state.pool)
    .await?;
    // --- КОНЕЦ ИЗМЕНЕНИЯ ---

    Ok(Json(user))
}

// --- БЛОК 4: Функция получения пользователя (остается без изменений) ---
pub async fn get_user(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<Json<User>, AppError> {
    let user = sqlx::query_as!(
        User,
        "SELECT * FROM users WHERE id = $1",
        id
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(user))
}

// --- БЛОК 5: Структура для данных входа (остается без изменений) ---
#[derive(Deserialize)]
pub struct LoginPayload {
    pub email: String,
    pub password: String,
}

// Структура для ответа API после успешного входа
#[derive(Serialize)]
pub struct AuthResponse {
    token: String,
}

// --- БЛОК 7: ОБНОВЛЕННАЯ функция login ---
pub async fn login(
    State(state): State<AppState>,
    Json(payload): Json<LoginPayload>,
) -> Result<Json<AuthResponse>, AppError> { // Обратите внимание на тип возврата!
    // 1. Найти пользователя по email
    let user = sqlx::query_as!(
        User,
        "SELECT * FROM users WHERE email = $1",
        payload.email
    )
    .fetch_optional(&state.pool)
    .await?
    .ok_or(AppError::InvalidCredentials)?;

    // 2. Проверить и склонировать хэш пароля
    let password_hash = user.password_hash.clone().ok_or(AppError::InvalidCredentials)?;

    // 3. Сравнить пароль с хэшем
    let password = payload.password;
    let verification_result = tokio::task::spawn_blocking(move || {
        let parsed_hash = match argon2::PasswordHash::new(&password_hash) {
            Ok(hash) => hash,
            Err(e) => return Err(e),
        };
        Argon2::default().verify_password(password.as_bytes(), &parsed_hash)
    })
    .await
    .map_err(|e| {
        tracing::error!("JoinError during password verification: {:?}", e);
        AppError::InternalServerError
    })?;

    // Если пароль верный, генерируем токен
    if verification_result.is_ok() {
        // --- Начало блока генерации JWT ---
        let now = Utc::now();
        // let iat = now.timestamp(); // iat (issued at) обычно не нужен, т.к. есть exp
        let exp = (now + Duration::days(1)).timestamp(); // Токен живет 1 дней
        
        let claims = Claims {
            sub: user.id,
            exp,
            pk: user.public_key.clone().unwrap_or_default(),
        };

        let token = encode(
            &Header::default(),
            &claims,
            &EncodingKey::from_secret(state.config.jwt_secret.as_ref()),
        )
        .map_err(|e| {
            tracing::error!("JWT encoding error: {:?}", e);
            AppError::InternalServerError
        })?;
        // --- Конец блока генерации JWT ---

        // Возвращаем токен
        Ok(Json(AuthResponse { token }))
    } else {
        // Если пароль неверный
        tracing::debug!("Invalid password attempt for email: {}", payload.email);
        Err(AppError::InvalidCredentials)
    }
}



/var/www/cyb3ria/src/handlers/message_handler.rs

// /var/www/cyb3ria/src/handlers/message_handler.rs

use axum::{
    extract::{Path, State, Json},
    Extension, // <-- Новый экстрактор!
};
// ... другие импорты
use uuid::Uuid;
use crate::{
    state::AppState,
    models::message::Message,
    error::AppError,
};
// ...

#[derive(serde::Deserialize)]
pub struct CreateMessagePayload {
    pub recipient_id: Uuid,
    pub content: String, // Сюда придет зашифрованная строка в Base64
}

#[axum::debug_handler]
pub async fn create_message(
    Extension(user_id): Extension<Uuid>, // <-- ВОТ ТАК мы получаем ID!
    State(state): State<AppState>,
    Json(payload): Json<CreateMessagePayload>,
) -> Result<Json<Message>, AppError> {
    // Проверяем, что пользователь не отправляет сообщение сам себе
    if user_id == payload.recipient_id {
        // Здесь можно вернуть кастомную ошибку, но для простоты пока оставим так
        return Err(AppError::InternalServerError); 
    }

    let message = sqlx::query_as!(
        Message,
        "INSERT INTO messages (user_id, recipient_id, content) VALUES ($1, $2, $3) RETURNING *",
        user_id, // Отправитель
        payload.recipient_id, // Получатель
        payload.content // Зашифрованное сообщение
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(message))
}

// ... get_message остается без изменений ...
pub async fn get_message(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<Json<Message>, AppError> {
    let message = sqlx::query_as!(
        Message,
        "SELECT * FROM messages WHERE id = $1",
        id
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(message))
}

// --- НОВАЯ ФУНКЦИЯ ---
pub async fn get_conversation_with(
    Extension(user_id): Extension<Uuid>, // ID текущего пользователя
    State(state): State<AppState>,
    Path(partner_id): Path<Uuid>, // ID собеседника из URL
) -> Result<Json<Vec<Message>>, AppError> {
    let messages = sqlx::query_as!(
        Message,
        // Этот запрос выбирает все сообщения, где текущий юзер - отправитель, а собеседник - получатель,
        // ИЛИ где собеседник - отправитель, а текущий юзер - получатель.
        // И сортирует их по дате создания.
        "SELECT * FROM messages 
         WHERE (user_id = $1 AND recipient_id = $2) OR (user_id = $2 AND recipient_id = $1)
         ORDER BY created_at ASC",
        user_id,
        partner_id
    )
    .fetch_all(&state.pool)
    .await?;

    Ok(Json(messages))
}



/var/www/cyb3ria/src/handlers/discussion_handler.rs

use axum::{
    extract::{Path, State},
    Json, 
};
use axum::Extension;

use uuid::Uuid;
use crate::{
    state::AppState,
    models::discussion::Discussion,
    error::AppError,
};


#[derive(serde::Deserialize)]
pub struct CreateDiscussionPayload {
    pub title: String,
}

pub async fn create_discussion(
    Extension(user_id): Extension<Uuid>, // <-- Получаем ID автора из токена
    State(state): State<AppState>,
    Json(payload): Json<CreateDiscussionPayload>,
) -> Result<Json<Discussion>, AppError> {
    let discussion = sqlx::query_as!(
        Discussion,
        "INSERT INTO discussions (title, author_id) VALUES ($1, $2) RETURNING *",
        payload.title,
        user_id // <-- Используем проверенный ID
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(discussion))
}

pub async fn get_discussion(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<Json<Discussion>, AppError> {
    let discussion = sqlx::query_as!(
        Discussion,
        "SELECT * FROM discussions WHERE id = $1",
        id
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(discussion))
}



/var/www/cyb3ria/src/handlers/comment_handler.rs

use axum::{
    extract::{Path, State},
    Json,
};
use uuid::Uuid;
use crate::{
    state::AppState,
    models::comment::Comment,
    error::AppError,
};
use axum::Extension;

#[derive(serde::Deserialize)]
pub struct CreateCommentPayload {
    pub discussion_id: Uuid,
    pub content: String,
}

pub async fn create_comment(
    Extension(user_id): Extension<Uuid>, // <-- ПОЛУЧАЕМ ID автора из токена
    State(state): State<AppState>,
    Json(payload): Json<CreateCommentPayload>,
) -> Result<Json<Comment>, AppError> {
    let comment = sqlx::query_as!(
        Comment,
        "INSERT INTO comments (discussion_id, author_id, content) VALUES ($1, $2, $3) RETURNING *",
        payload.discussion_id,
        user_id, // <-- ИСПОЛЬЗУЕМ безопасный ID из токена
        payload.content
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(comment))
}

pub async fn get_comment(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<Json<Comment>, AppError> {
    let comment = sqlx::query_as!(
        Comment,
        "SELECT * FROM comments WHERE id = $1",
        id
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(comment))
}



/var/www/cyb3ria/src/models/mod.rs

pub mod user;
pub mod message;
pub mod discussion;
pub mod comment;




/var/www/cyb3ria/src/models/user.rs

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct User {
    pub id: Uuid,
    pub username: String,
    pub email: String,
    pub public_key: Option<String>,

    // Добавляем недостающее поле
    // Оно Option<String>, так как в БД колонка может быть NULL.
    // Оно скрыто из JSON-ответов для безопасности.
    #[serde(skip_serializing)]
    pub password_hash: Option<String>,

    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}



/var/www/cyb3ria/src/models/message.rs

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

// Убедитесь, что здесь НЕТ поля `discussion_id`.
#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct Message {
    pub id: Uuid,
    pub user_id: Uuid,
    pub recipient_id: Option<Uuid>,
    pub content: String,
    pub created_at: DateTime<Utc>,
}



/var/www/cyb3ria/src/models/discussion.rs

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct Discussion {
    pub id: Uuid,
    pub title: String,
    pub author_id: Uuid, // <- Добавлено это поле
    pub created_at: DateTime<Utc>,
}



/var/www/cyb3ria/src/models/comment.rs

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct Comment {
    pub id: Uuid,
    pub discussion_id: Uuid,
    pub author_id: Uuid, // <- Переименовано с user_id на author_id
    pub content: String,
    pub created_at: DateTime<Utc>,
}



/var/www/cyb3ria/static/index.html

<!-- /var/www/cyb3ria/static/index.html -->
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyb3ria Project</title>
    
    <!-- Вот самая важная строка для иконки! -->
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    
    <!-- Подключаем стили, если нужно -->
    <link rel="stylesheet" href="/static/statix.css">
</head>
<body>
    <div class="container">
        <h1>Сайт работает!</h1>
        <p>Эта страница (index.html) и иконка были успешно отданы Rust-бэкендом через Nginx.</p>
    </div>
</body>
</html>



/var/www/cyb3ria/static/statix.css

/* Простой тестовый CSS */
body {
    font-family: Arial, sans-serif;
    background-color: #f0f0f0;
    color: #333;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}



/var/www/cyb3ria/migrations/20250810000001_create_users_table.sql

-- Add migration script here

-- Создаем расширение, если оно еще не установлено, для использования UUID
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Создаем таблицу пользователей
CREATE TABLE users (
-- Уникальный идентификатор пользователя, генерируется автоматически
id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

-- Имя пользователя, должно быть уникальным и непустым
username VARCHAR(255) UNIQUE NOT NULL,

-- Хеш пароля. Никогда не храните пароли в открытом виде!
-- Поле может быть NULL, так как у нас будет аутентификация без пароля (passkeys).
password_hash VARCHAR(255),

-- Email, должен быть уникальным.
email VARCHAR(255) UNIQUE NOT NULL,

-- Временные метки
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Добавляем триггер для автоматического обновления поля updated_at
-- при любом изменении строки. Это очень удобно.
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
NEW.updated_at = NOW();
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_timestamp
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();



/var/www/cyb3ria/migrations/20250810000002_create_messages.sql

CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);



/var/www/cyb3ria/migrations/20250810000003_create_discussions.sql

CREATE TABLE discussions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title TEXT NOT NULL,
    author_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);




/var/www/cyb3ria/migrations/20250810000004_create_comments.sql

CREATE TABLE comments (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    discussion_id UUID NOT NULL REFERENCES discussions(id) ON DELETE CASCADE,
    author_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);




/var/www/cyb3ria/migrations/20250810000005_add_public_key_to_users.sql

-- Add up migration script here
ALTER TABLE users ADD COLUMN public_key TEXT;

-- Add down migration script here
 ALTER TABLE users DROP COLUMN public_key;



/var/www/cyb3ria/migrations/20250810000006_add_recipient_to_messages.sql

-- Add up migration script here
-- Добавляем колонку для ID получателя
ALTER TABLE messages ADD COLUMN recipient_id UUID;

-- Создаем связь с таблицей users, чтобы нельзя было отправить сообщение несуществующему пользователю
ALTER TABLE messages ADD CONSTRAINT fk_recipient
    FOREIGN KEY (recipient_id) REFERENCES users(id) ON DELETE SET NULL;

-- 'Down' миграция для отката
-- Add down migration script here
ALTER TABLE messages DROP CONSTRAINT fk_recipient;
ALTER TABLE messages DROP COLUMN recipient_id;



